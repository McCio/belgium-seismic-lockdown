
```{r libraries, include=FALSE}
library(knitr)
opts_chunk$set(warning = F, message = F)
library(stringi) # %s+%
library(lubridate) # floor_date
library(xts) # zoo
library(fpp) # auto.arima
# library(gridExtra) # for gg-plotting multiple plots
library(cowplot) # for plot_grid
library(car) # qqPlot
library(tidyverse) # map_df, read_csv, group_by, summarize
library(tsbox) # https://cran.r-project.org/web/packages/tsbox/vignettes/tsbox.html
print_dec <- function(x, decimals=2) trimws(format(round(x, decimals), nsmall=decimals))

setwd("/media/data/Documents/Uni/spatiotemp/villalobos/project/")
```


```{r import dataset, include=FALSE}
if (!exists("domain")) {
  # UCCS
  domain <- c(-350000,350000); pattern <- "UCCS.*\\.csv"; name <- "UCCS"; description <- "Uccle, Bruxelles"; proj_file <- 'proj.uccs.RData'
  # MEMS
  domain <- c(-7200,7200); pattern <- "MEM.*\\.csv"; name <- "MEM"; description <- "Membach"; proj_file <- 'proj.mems.RData'
}
if (exists("proj_file")) {
  load(paste0("/media/data/Documents/Uni/spatiotemp/villalobos/project/", proj_file))
  # save.image(paste0("/media/data/Documents/Uni/spatiotemp/villalobos/project/", proj_file))
}
seis <-
  list.files(path="csv/", pattern=pattern) %>%
  map_df(~read_csv("csv/" %s+% .))
```



# Data preparation
```{r dataset description, echo=FALSE}
long_description <- description %s+% " (" %s+% name %s+% " station)"
long_description
"Domain values: " %s+% domain[1] %s+% " to " %s+% domain[2] %s+% " nm"
"Data from " %s+% format.POSIXct(min(seis$utc_second), "%Y-%m-%d %H:%M:%S") %s+% " to " %s+% format.POSIXct(max(seis$utc_second), "%Y-%m-%d %H:%M:%S")
```

```{r cleanup, echo=FALSE}
out_domain <- (seis$min < domain[1] | seis$max > domain[2])
invalid_values <- (seis$min == -1 & seis$max == 1) | (seis$min == 0 & seis$max == 0) | out_domain
"Removing " %s+% sum(out_domain) %s+% " values out of domain, " %s+% (sum(invalid_values) - sum(out_domain)) %s+% " explicit NA"
seis <-
  seis %>%
  mutate(min=replace(min, invalid_values, NA), max=replace(max, invalid_values, NA)) %>%
  drop_na()
# %>% mutate(belgian_second=with_tz(utc_second, "Europe/Brussels"))
remove(out_domain, invalid_values) # free ~350 Mb from RAM
```

```{r missing values analysis}
seis.complete <- seis %>% complete(utc_second=seq.POSIXt(from=min(seis$utc_second), to=max(seis$utc_second), by = as.difftime("0:0:1")))
seis.first.second <- min(seis$utc_second)
seis.missing.ids <- which(is.na(seis.complete$min))

seis.present <- length(seis$utc_second)
seis.total <- length(seis.complete$utc_second)
seis.missing <- seis.total - seis.present
  seis.present %s+% " present values, " %s+% seis.missing %s+% " missing points (" %s+% print_dec(seis.present / seis.total * 100, 2) %s+% "% / " %s+% print_dec(seis.missing / seis.total * 100, 2) %s+% "%)"

block_start <- NULL
block_end <- NULL
blocks <- data.frame(start=integer(), end=integer())
for (i in 1:length(seis.missing.ids)) {
  if (is.null(block_start)) {
    block_start <- seis.missing.ids[i]
    block_end <- seis.missing.ids[i]
  } else if ((block_end + 1) == seis.missing.ids[i]) {
    block_end <- seis.missing.ids[i]
  } else {
    blocks[nrow(blocks) + 1, ] <- c(block_start, block_end)
    block_start <- seis.missing.ids[i]
    block_end <- seis.missing.ids[i]
  }
}
blocks[nrow(blocks) + 1, ] <- c(block_start, block_end)
blocks$interval <- seconds(blocks$end - blocks$start + 1)
blocks$start <- seis.first.second + seconds(blocks$start)
blocks$end <- seis.first.second + seconds(blocks$end)
plot(blocks$start, blocks$interval,
     col=ifelse(blocks$interval<3600, "darkgreen", "darkred"),
     main="Consecutive seconds of missing values",
     ylab="Seconds", xlab="Interval start",
     xaxt="n", xlim=c(min(seis$utc_second), max(seis$utc_second))
     )
axis.POSIXct(1, at=seq.POSIXt(from=min(seis$utc_second), to=max(seis$utc_second), by = "1 month"), format="%m-%y", cex=0.8)
abline(h=3600, col="green", lty="dotted")
legend("topleft", legend=c("interval >= 1h", "interval < 1h", "1h"), col=c("darkred", "darkgreen", "green"), lty=c(NA,NA,3), pch=c(1,1,NA),cex=0.9, bty="n")
text(x=blocks$start[which(blocks$interval > 3600)], y=blocks$interval[which(blocks$interval > 3600)], labels = paste0(blocks$start[which(blocks$interval > 3600)], " - ", blocks$end[which(blocks$interval > 3600)]), cex=0.9, pos=4)
remove(seis.complete, seis.missing.ids)
```


```{r gc_post_missing_analysis, include=FALSE}
gc()
```

```{r group by hour, include=FALSE}
bruxelles <- function(d) with_tz(d, "Europe/Brussels")
force_bruxelles <- function(d) force_tz(d, "Europe/Brussels")

seis.h <- 
  seis %>%
  # mutate(utc_hour=as_datetime(date(utc_second)) + hour(utc_second) * 3600) %>% # this forces the hour to represent bruxelles local time in utc. tz-ed time is normally evaluated in utc by ts-related functions
  group_by(utc_hour=floor_date(force_tz(bruxelles(utc_second), "UTC"), "1 hour")) %>%
  summarize(mean_movement_s=mean(max-min)) # %>%
#  complete(utc_hour=seq.POSIXt(from=min(seis$utc_second), to=max(seis$utc_second), by = as.difftime("1:0:0")))

seis.before <- 
  seis.h[which(is.na(force_bruxelles(seis.h$utc_hour) + hours(1))), ] %>%
  mutate(utc_hour=utc_hour + hours(1))

seis.after <- 
  seis.h[which(is.na(force_bruxelles(seis.h$utc_hour) - hours(1))), ] %>%
  mutate(utc_hour=utc_hour - hours(1))

seis.dst.fix <-
  merge(seis.before, seis.after, all=T) %>%
  group_by(utc_hour=utc_hour) %>%
  summarize(mean_movement_s=mean(mean_movement_s))

seis.h <- merge(seis.h, seis.dst.fix, all=T)
remove(seis.after, seis.before, seis.dst.fix)
gc()
```



```{r missing values hour analysis}
seis.complete <- seis.h %>% complete(utc_hour=seq.POSIXt(from=min(seis.h$utc_hour), to=max(seis.h$utc_hour), by = as.difftime("1:0:0")))
seis.first.second <- min(seis$utc_second)
seis.missing.ids <- which(is.na(seis.complete$mean_movement_s))

seis.present <- length(seis.h$utc_hour)
seis.total <- length(seis.complete$utc_hour)
seis.missing <- seis.total - seis.present
seis.present %s+% " present values, " %s+% seis.missing %s+% " missing points (" %s+% print_dec(seis.present / seis.total * 100, 2) %s+% "% / " %s+% print_dec(seis.missing / seis.total * 100, 2) %s+% "%)"

block_start <- NULL
block_end <- NULL
blocks <- data.frame(start=integer(), end=integer())
for (i in 1:length(seis.missing.ids)) {
  if (is.null(block_start)) {
    block_start <- seis.missing.ids[i]
    block_end <- seis.missing.ids[i]
  } else if ((block_end + 1) == seis.missing.ids[i]) {
    block_end <- seis.missing.ids[i]
  } else {
    blocks[nrow(blocks) + 1, ] <- c(block_start, block_end)
    block_start <- seis.missing.ids[i]
    block_end <- seis.missing.ids[i]
  }
}
blocks[nrow(blocks) + 1, ] <- c(block_start, block_end)
blocks$interval <- hours(blocks$end - blocks$start + 1)
blocks$start <- seis.first.second + hours(blocks$start)
blocks$end <- seis.first.second + hours(blocks$end)
plot(c(rbind(blocks$start, blocks$end, NA)), rep(hour(blocks$interval), each=3),
     col=ifelse(blocks$interval<3600, "darkgreen", "darkred"),
     main="Consecutive hours of missing values",
     ylab="Hours", xlab="Interval start",
     type="l", lwd=10,
     xaxt="n", xlim=c(min(seis$utc_second), max(seis$utc_second))
     )
axis.POSIXct(1, at=seq.POSIXt(from=min(seis$utc_second), to=max(seis$utc_second), by = "1 month"), format="%m-%y", cex=0.8)
text(x=blocks$start, y=hour(blocks$interval), labels = paste0(format(blocks$start, "%y-%m-%d %H:%M")), cex=0.9, pos=2)
text(x=blocks$end, y=hour(blocks$interval), labels = paste0(format(blocks$end, "%y-%m-%d %H:%M")), cex=0.9, pos=4)
text(x=blocks$start + make_difftime(hour=sapply(hour(blocks$interval), "/", y=2)), y=hour(blocks$interval), labels = paste0(hour(blocks$interval), "H"), cex=0.9, pos=3)
remove(seis.complete, seis.missing.ids)

blocks$interval
Box.test(seis.h$mean_movement_s, type="Box-Pierce")

```

```{r gc_post_missing_analysis_bru, include=FALSE}
gc()
```

```{r build_ts function, include=FALSE}
build_ts <- function(dset, periods=NULL, start=NULL, end=NULL, force_ms=T) {
  dset.ts <- ts_zoo(dset)
  if (!is.null(start) | !is.null(end)) {
    dset.ts <- ts_span(dset.ts, start=start, end=end)
  }
  dset.ts <- ts_regular(dset.ts)
  if (is.null(periods)) {
    return(dset.ts)
  }
  if (is.vector(periods) & length(periods) == 1) {
    periods <- periods[1]
  }
  if (is.integer(periods)){
    if (force_ms) {
      periods <- c(periods)
    } else {
      frequency(dset.ts) <- periods
      return(dset.ts)
    }
  }
  return(msts(dset.ts, periods))
}
```





```{r test_train split ts, include=FALSE}
seis.h.start <- as_datetime('2018-10-29T00:00:00')
seis.h.end <- as_datetime('2020-03-02T00:00:00') - seconds(1)
seasonality.period <- 24
seasonality.xlab <- "Days"
seasonality.aggregate <- function(ds) na.aggregate(seis.h.ts, function(x) floor(x/14))
seasonality.period <- 168
seasonality.xlab <- "Weeks"
seasonality.aggregate <- function(ds) na.aggregate(ds, floor)
seis.h.ts <- build_ts(seis.h, periods = c(seasonality.period), start = seis.h.start, end = seis.h.end, force_ms = T)

seis.test.split <- seis.h.start + days(52*7)

seis.train.start <- seis.h.start
seis.train.end <- seis.test.split - seconds(1)
seis.h.train <- build_ts(seis.h, periods = c(seasonality.period), start = seis.train.start, end = seis.train.end, force_ms = T)

seis.test.start <- seis.test.split
seis.test.end <- as_datetime('2020-05-04T00:00:00') - seconds(1)
seis.h.test <- build_ts(seis.h, periods = c(seasonality.period), start = seis.h.start, end = seis.test.end, force_ms = T)
seis.h.test <- window(seis.h.test, start = c(end(seis.h.train)[1] + 1, 1))
seis.test.length <- length(seis.h.test)
```



```{r plot data with (p)acf}
seis.h.24 <- build_ts(seis.h, periods = c(24), start = seis.h.start, end = seis.h.end)
seasonplot(seis.h.24, type="l", col=rainbow(7))
legend("topleft", legend=weekdays(seis.h.start + (as.difftime(c(0:6), units="days"))), col=rainbow(7), lty=1, cex=0.8)

plot_grid(
  autoplot(seis.h.ts, main = "Hourly seismic movement", xlab = seasonality.xlab, ylab = "mean movement (nm)"),
  gghistogram(seis.h.ts, add.normal = T) + xlab("mean movement (nm)"),
  nrow = 2)
plot_grid(
  autoplot(acf(seis.h.ts, na.action=na.pass, plot=F, lag.max=seasonality.period)) + scale_x_continuous(),
  autoplot(pacf(seis.h.ts, na.action=na.pass, plot=F, lag.max=seasonality.period)) + scale_x_continuous(),
  nrow = 2)


```
Once notice the composition is additive (the fluctuations does not seem to grow with the trend)
```{r decompose}
dec.addi <- decompose(seasonality.aggregate(seis.h.ts))
autoplot(dec.addi) + labs(title="Decomposition of additive time series", subtitle = paste0("Seasonality ", seasonality.period))
dec.multi <- decompose(log(seasonality.aggregate(seis.h.ts)))
autoplot(dec.multi) + labs(title="Decomposition of multiplicative time series (log-scale additive)", subtitle = paste0("Seasonality ", seasonality.period))
plot_grid(
  autoplot(acf(dec.addi$random, na.action=na.omit, plot=F)) + scale_x_continuous(),
  autoplot(acf(dec.multi$random, na.action=na.omit, plot=F)) + scale_x_continuous(),
  nrow = 2)
plot_grid(
  autoplot(pacf(dec.addi$random, na.action=na.omit, plot=F)) + scale_x_continuous(),
  autoplot(pacf(dec.multi$random, na.action=na.omit, plot=F)) + scale_x_continuous(),
  nrow = 2)
```

We now extract the trend using a linear filter with smoothing parameter $p$ equal to 180 (almost half a year):

```{r linear trend}
p <- floor(seasonality.period/2)
weights <- rep(1/(2*p+1), times=2*p+1)
trend <- stats::filter(seasonality.aggregate(seis.h.ts), sides=2, filter = weights)
```


```{r show_overlap_and_diff, include=FALSE}
show_overlap_and_diff <- function(base, compare, base.desc, compare.desc, xlab, overlap.ylab, diff.title, diff.ylab, diff.ylab.sec, diff.ylab.sec.accuracy=.1) {
  overlap_plot <-
    autoplot(compare, xlab=xlab, ylab=overlap.ylab) +
      geom_line(aes(y=base, col="red"), show.legend = F) +
      labs(title=paste0(base.desc, " vs ", compare.desc))
  span <- max(compare, base, na.rm = T) - min(compare, base, na.rm = T)
  diff <- compare-base
  accu.lims <- diff.ylab.sec.accuracy / 100 * span * c(-3,3)

  mse <- mean(diff^2, na.rm = T)
  mae <- mean(abs(diff), na.rm = T)
  rmse <- sqrt(mse)
  R2 <- 1-(sum((diff)^2, na.rm = T)/sum((base-mean(base))^2, na.rm = T))
  errorstring <- paste0("MSE=", mse, "    MAE=", mae, "    RMSE=", rmse, "    R2=", R2)
  print(errorstring)


  diff_plot <-
    autoplot(diff, ylab = paste0("Difference (", diff.ylab, ")"), xlab = xlab) +
      expand_limits(y=accu.lims) +
      labs(title = diff.title, subtitle = paste0(base.desc, " - ", compare.desc)) +
      scale_y_continuous(sec.axis = sec_axis(~./span, name=paste0("Difference (", diff.ylab.sec, ")"), labels = scales::percent_format(accuracy = diff.ylab.sec.accuracy))) +
      geom_hline(yintercept=mean(diff, na.rm=T), linetype="dashed", color = "red")
  return(list(overlap_plot, diff_plot))
}
```


And they match:
```{r linear trend plot}
plots <- show_overlap_and_diff(
  dec.addi$trend, trend, xlab=seasonality.xlab,
  base.desc = "additive decomposition trend",
  compare.desc = paste0("linear filtered trend with p=", p),
  overlap.ylab = "Trend (nm)",
  diff.title = "Difference between trends",
  diff.ylab = "nm", diff.ylab.sec="% over trend span"
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)

```

Then we use a filter able also to capture some seasonal effect so we will be able to find the residuals. We are going to choose $f=365$ so to have the moving average from the first day of the year to the last one and then shifted from the second day of the year to the first one of the following year and so, this is because we believe to have an yearly seasonality.

```{r trend MA}
f <- seasonality.period
weights.s <- c(0.5, rep(1,f-1), 0.5)/f
trend.s <- stats::filter(seasonality.aggregate(seis.h.ts), side=2, filter=weights.s)

plots <- show_overlap_and_diff(
  dec.addi$trend, trend.s, xlab=seasonality.xlab,
  base.desc = "additive decomposition trend",
  compare.desc = paste0("shift-filtered trend with f=", f),
  overlap.ylab = "Trend (nm)",
  diff.title = "Difference between trends",
  diff.ylab = "nm", diff.ylab.sec="% over trend span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)


```

and they match (with some error of course) with the ones found with the decompose function.

Finally we want to prove we can retrieve seasonality, in order to do so we can compute the average seasonality starting from the detrended series: to do so we put the time series into a matrix and we transform this matrix so each column contains elements of the same period and finally, we compute the mean of each column. We will check this with the element figure of the object decomposition i.e. the estimated seasonal figure not repeated for all the time series. 

```{r trend figure}
detrended <- seasonality.aggregate(seis.h.ts)-trend.s
detrended <- window(detrended, end = c(end(detrended)[1], seasonality.period), extend=T)
matrix <- t(matrix(data = detrended, nrow = seasonality.period))
seasonality.figure <- as.ts(colMeans(matrix, na.rm = T))
seasonality <- rep(seasonality.figure, length(detrended)/length(seasonality.figure))[1:length(trend.s)]
```

and they almost match: 

```{r difference of trend figure}

plots <- show_overlap_and_diff(
  dec.addi$figure, seasonality.figure, xlab=seasonality.xlab,
  base.desc = "additive decomposition",
  compare.desc = paste0("mean-over-period after removal of shift-filtered trend with f=", f),
  overlap.ylab = "Seasonality (nm)",
  diff.title = paste0("Difference between seasonalities (f=", seasonality.period, ")"),
  diff.ylab = "nm", diff.ylab.sec="% over seasonality span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)

# difference is maybe given by na.aggregate used in decompose, while na.rm=T in manual seasonality?
```

```{r residuals}
residuals <- seasonality.aggregate(seis.h.ts) - trend.s - seasonality

plots <- show_overlap_and_diff(
  dec.addi$random, residuals, xlab=seasonality.xlab,
  base.desc = "additive decomposition",
  compare.desc = paste0("mean-over-period after removal of shift-filtered trend with f=", f),
  overlap.ylab = "Residuals (nm)",
  diff.title = paste0("Difference between residuals (f=", seasonality.period, ")"),
  diff.ylab = "nm", diff.ylab.sec="% over residuals span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)

residuals.acf <- autoplot(acf(residuals, na.action = na.pass, plot=F)) + scale_x_continuous()
residuals.pacf <- autoplot(pacf(residuals, na.action = na.pass, plot=F)) + scale_x_continuous()
plot_grid(residuals.acf, residuals.pacf, nrow=2)


```

In fact we are able to reconstruct the original series, with of course some missing value at the beginning and at the end because of the methods applied previously:

```{r difference of reconstruct}
ts <- residuals+trend.s+seasonality

plots <- show_overlap_and_diff(
  seis.h.ts, ts, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)

plots <- show_overlap_and_diff(
  seis.h.ts, dec.addi$trend+dec.addi$seasonal+dec.addi$random, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)

```




```{r extract both 24 and 168}
trend.s_compute <- function(ts.in, period) {
  f <- period
  weights.s <- c(0.5, rep(1,f-1), 0.5)/f
  trend.s <- stats::filter(ts.in, side=2, filter=weights.s)
  return(trend.s)
}

season_by_mean <- function(ts.in, period) {
  freq <- frequency(ts.in)
  if (freq == period) {
    end <- c(end(ts.in)[1], period)
  } else {
    end <- c(((end(ts.in)[1] * freq) %/% period + 1) * (period/freq), freq)
  }
  extended <- window(ts.in, end = end, extend=T)
  matrix <- t(matrix(data = extended, nrow = period))
  seasonality.figure <- as.ts(colMeans(matrix, na.rm = T))
  seasonality <- rep(seasonality.figure, length(extended)/length(seasonality.figure))[1:length(ts)]
  return(list(figure=seasonality.figure, seasonal=seasonality))
}

trend_season <- function(ts.in, period) {
  trend.s <- trend.s_compute(ts.in, period)
  season <- season_by_mean(ts.in-trend.s, period)
  season$trend <- trend.s
  return(season)
}

aggregated <- seasonality.aggregate(seis.h.ts)
season.24 <- trend_season(aggregated, 24)
season.168 <- trend_season(aggregated-season.24$seasonal, 168)

season.24 <- trend_season(aggregated-season.168$seasonal, 24)
season.168 <- trend_season(aggregated-season.24$seasonal, 168)

# this third iteration isn't actually needed
season.24 <- trend_season(aggregated-season.168$seasonal, 24)
season.168 <- trend_season(aggregated-season.24$seasonal, 168)

plot_grid(
  autoplot(aggregated) + labs(title="Timeseries", cex=0.7) + ylab("") + xlab("") + theme(plot.margin=margin(b=-6, unit="pt")),
  autoplot(ts(season.24$figure, frequency=1)) + labs(title="Daily seasonality", cex=0.7) + ylab("") + xlab("") + theme(plot.margin=margin(r=10, b=-6, unit="pt")),
  autoplot(ts(season.168$trend, frequency=168)) + labs(title="Trend", cex=0.7) + ylab("") + xlab("") + theme(plot.margin=margin(l=4, b=-6, unit="pt")),
  autoplot(ts(season.168$figure, frequency=1)) + labs(title="Weekly seasonality", cex=0.7) + ylab("") + xlab("") + theme(plot.margin=margin(r=10, b=-6, unit="pt")),
  autoplot(aggregated-season.24$seasonal-season.168$seasonal-season.168$trend) + labs(title="Residuals", cex=0.7) + ylab("") + xlab("") + theme(plot.margin=margin(t=-6, b=-6, unit="pt")),
  nrow = 3,
  greedy = T)


seasonbase.24 <- trend_season(aggregated, 24)
seasonbase.168 <- trend_season(aggregated, 168)

plot_grid(
  autoplot(ts(seasonbase.24$figure, frequency=1)) + ylab("") + xlab("Hours") + scale_x_continuous() + geom_line(aes(col="Direct daily"), size=1.5) +
    geom_line(aes(y=season.24$figure, col="Multi daily")) +
    scale_colour_manual("", values=c("purple", "yellow"), breaks=c("Direct daily", "Multi daily")),
  autoplot(ts(seasonbase.168$figure, frequency=1)) + ylab("") + xlab("Hours") + scale_x_continuous() + geom_line(aes(col="Direct weekly"), size=1.5) +
    geom_line(aes(y=season.168$figure + rep(season.24$figure, 7), col="Multi w+d")) +
    #geom_line(aes(y=rep(seasonbase.24$figure, 7), col="Direct daily"), size=1.5) +
    #geom_line(aes(y=rep(season.24$figure, 7), col="Multi daily")) +
    geom_line(aes(y=season.168$figure, col="Multi weekly")) +
    scale_colour_manual("", values=c("red", "purple", "blue", "yellow", "green"), breaks=c("Direct weekly", "Direct daily", "Multi" %s+% c(" weekly", " daily", " w+d"))),
  nrow = 2)


plots <- show_overlap_and_diff(
  seasonbase.168$figure, season.168$figure + rep(season.24$figure, 7), xlab="Hours",
  base.desc = "168 from ds",
  compare.desc = "168+24 from ds",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between 168",
  diff.ylab = "nm", diff.ylab.sec="% over season span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)


```

















```{r diffs acf/pacf}
seis.h.train %>% ggtsdisplay(lag.max = 168*5)
seis.h.train %>% diff() %>% ggtsdisplay(lag.max = 168*5)
# seis.h.train %>% diff(D=2) %>% ggtsdisplay(lag.max = 168)
# seis.h.train %>% diff(lag=24) %>% ggtsdisplay(lag.max = 168)
# seis.h.train %>% diff() %>% diff(lag=24) %>% ggtsdisplay(lag.max = 24, main="Supposed model: ARIMA(24,1,0)(0,1,2)[24]") # ARIMA(0,1,0)(0,1,2)[24]
# previous => ARIMA(5,1,0)(0,1,7)[24]
# seis.h.train %>% diff() %>% diff(lag=24, D=2) %>% ggtsdisplay(lag.max = 168)
seis.h.train %>% diff(lag=168) %>% ggtsdisplay(lag.max = 168*5) # arima (0,0,0)(0,1,1/2)[168]
# acf variable and partially sinusoidal, pacf shows peaks each 168
seis.h.train %>% diff() %>% diff(lag=168) %>% ggtsdisplay(lag.max = 168*5) # arima (0,1,0)(0,1,1)[168]
# acf cuts off after p=168, pacf shows peaks each 168
# seis.h.train %>% diff() %>% diff(lag=168, D=2) %>% ggtsdisplay(lag.max = 168)
seis.h.train %>% diff() %>% diff(lag=24) %>% diff(lag=168) %>% ggtsdisplay(lag.max = 168*5)
```

```{r plot_forecast func}
plot_forecast <- function(forec) {
  BP <- Box.test(forec$model$residuals, type="Box-Pierce")
  autoplot(forec) +
    labs(title=forec$method, subtitle = paste0("Box-Pierce p-value=", print_dec(BP$p.value, decimals=4))) +
    autolayer(forec$mean, series="Forecast") -> plotted
  return(plotted)
}
```


```{r arima}
to_test <- list(
  #c(0,0,0,0,0,1),  # BAD, Box-Pierce = 0
  #c(0,0,0,0,0,2),  # BAD, Box-Pierce = 0
  #c(0,0,0,0,1,1),  # nice, Box-Pierce = 0
  c(0,0,0,0,1,2),
  #c(0,0,0,0,1,3),  # CAN'T BE DONE: 3*168 = 504 > 350 (limit of arima on r)
  #c(0,1,0,0,0,1),  # BAD, Box-Pierce = 0
  c(0,1,0,0,1,1),
  c(0,1,0,0,1,2),
  c(2,0,0,0,1,0),  # hint from auto.arima D=1
  c(5,0,0,0,1,0),  # hint from auto.arima D=1
  c(3,1,1,0,1,0),  # hint from auto.arima D=1 d=1
  c(3,1,1,0,1,1),  # after hint then ACF + PACF
  c(4,1,2,0,1,0),  # hint from auto.arima d=1, D=1, max.p=5, max.q=2, max.P=5, max.Q=2, max.order=10
  c(4,1,2,0,1,1)  # after hint then ACF + PACF
)
if (!exists("models")){
  models <- list()
}
for (model in to_test) {
  # model <- c(4,1,2,0,1,0)
  fit.name <- paste0("fit", paste0(model, collapse = ""))
  forecast.name <- paste0("forecast", paste0(model, collapse = ""))
  print("SARIMA(" %s+% paste0(model[1:3], collapse = ",") %s+% ")(" %s+% paste0(model[4:6], collapse = ",") %s+% ")[" %s+% frequency(seis.h.train) %s+% "]")
  if (!(fit.name %in% names(models))) {
    models[[fit.name]] <- Arima(seis.h.train, model[1:3], model[4:6])
  }
  if (!(forecast.name %in% names(models))) {
    models[[forecast.name]] <- forecast(models[[fit.name]], h=168*18)
  }
}
#models[["fitauto"]] <- auto.arima(seis.h.train, D=1, approx=F, trace = T)
#models[["forecastauto"]] <- forecast(models[["fitauto"]], h=168*18)  
#models[["fit311010"]] <- models[["fitauto"]]
#models[["fit412010"]] <- fit
#models[["forecast412010"]] <- forecast(models[["fit412010"]], h=168*18)

# 000012 better than 000011, Box-Pierce = 0
plotting.model <- models[["fit000012"]]
plotting.forecast <- models[["forecast000012"]]
# 010011 somehow better somehow worst than 000012, Box-Pierce = 0
plotting.model <- models[["fit010011"]]
plotting.forecast <- models[["forecast010011"]]
# 010012 , Box-Pierce = 
plotting.model <- models[["fit010012"]]
plotting.forecast <- models[["forecast010012"]]
# 311010 , Box-Pierce = 
plotting.model <- models[["fit311010"]]
plotting.forecast <- models[["forecast311010"]]
# 311011 , Box-Pierce = 
plotting.model <- models[["fit311011"]]
plotting.forecast <- models[["forecast311011"]]

checkresiduals(plotting.model)
residuals.acf <- autoplot(acf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
residuals.pacf <- autoplot(pacf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
plot_grid(residuals.acf, residuals.pacf, nrow=2)
plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original")
plots <- show_overlap_and_diff(
  seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
accuracy(plotting.forecast, seis.h.test)




plotting.model <- models[["fit010012"]]
plotting.forecast <- models[["forecast010012"]]
checkresiduals(plotting.model)
residuals.acf <- autoplot(acf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
residuals.pacf <- autoplot(pacf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
plot_grid(residuals.acf, residuals.pacf, nrow=2)
plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original")
plots <- show_overlap_and_diff(
  seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
accuracy(plotting.forecast, seis.h.test)

plotting.model <- models[["fit412010"]]
plotting.forecast <- models[["forecast412010"]]
checkresiduals(plotting.model)
residuals.acf <- autoplot(acf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
residuals.pacf <- autoplot(pacf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
plot_grid(residuals.acf, residuals.pacf, nrow=2)
plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original") 
plots <- show_overlap_and_diff(
  seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
accuracy(plotting.forecast, seis.h.test)



plotting.model <- models[["fit500010"]]
plotting.forecast <- models[["forecast500010"]]
checkresiduals(plotting.model)
residuals.acf <- autoplot(acf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
residuals.pacf <- autoplot(pacf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
plot_grid(residuals.acf, residuals.pacf, nrow=2)
plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original") 
plots <- show_overlap_and_diff(
  seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
  base.desc = "original series",
  compare.desc = "reconstructed series",
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
accuracy(plotting.forecast, seis.h.test)



for (model in to_test) {
  # model <- c(4,1,2,0,1,0)
  fit.name <- paste0("fit", paste0(model, collapse = ""))
  forecast.name <- paste0("forecast", paste0(model, collapse = ""))
  print("SARIMA(" %s+% paste0(model[1:3], collapse = ",") %s+% ")(" %s+% paste0(model[4:6], collapse = ",") %s+% ")[" %s+% frequency(seis.h.train) %s+% "]")
  if ((fit.name %in% names(models))) {  if ((forecast.name %in% names(models))) {
    plotting.model <- models[[fit.name]]
    plotting.forecast <- models[[forecast.name]]
    checkresiduals(plotting.model)
    residuals.acf <- autoplot(acf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
    residuals.pacf <- autoplot(pacf(plotting.model$residuals, na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
    plot_grid(residuals.acf, residuals.pacf, nrow=2)
    plot_forecast(plotting.forecast) + 
      autolayer(seis.h.test, series="Original") 
    plots <- show_overlap_and_diff(
      seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
      base.desc = "original series",
      compare.desc = paste0("refit with ", plotting.forecast$method),
      overlap.ylab = "Mean hourly movement (nm)",
      diff.title = "Difference between ts",
      diff.ylab = "nm", diff.ylab.sec="% over ts span",
      diff.ylab.sec.accuracy = .01
    )
    plot_grid(plots[[1]], plots[[2]], nrow = 2)
    accuracy(plotting.forecast, seis.h.test)
  }}
}
qqPlot(models[["fit500010"]]$residuals)
```


```{r}
#fit <- auto.arima(seis.h.train, d=1, D=1, max.p=5, max.q=2, max.P=5, max.Q=2, max.order=10, trace = T, parallel = T)
```
# D=1 m=24
 Fitting models using approximations to speed things up...

 ARIMA(2,0,2)(1,1,1)[24] with drift         : Inf
 ARIMA(0,0,0)(0,1,0)[24] with drift         : 111462.7
 ARIMA(1,0,0)(1,1,0)[24] with drift         : 101954.4
 ARIMA(0,0,1)(0,1,1)[24] with drift         : Inf
 ARIMA(0,0,0)(0,1,0)[24]                    : 111460.9
 ARIMA(1,0,0)(0,1,0)[24] with drift         : 102426.5
 ARIMA(1,0,0)(2,1,0)[24] with drift         : 101379
 ARIMA(1,0,0)(2,1,1)[24] with drift         : Inf
 ARIMA(1,0,0)(1,1,1)[24] with drift         : Inf
 ARIMA(0,0,0)(2,1,0)[24] with drift         : 110647.6
 ARIMA(2,0,0)(2,1,0)[24] with drift         : 101332.9
 ARIMA(2,0,0)(1,1,0)[24] with drift         : 101878.7
 ARIMA(2,0,0)(2,1,1)[24] with drift         : Inf
 ARIMA(2,0,0)(1,1,1)[24] with drift         : Inf
 ARIMA(3,0,0)(2,1,0)[24] with drift         : 101317.9
 ARIMA(3,0,0)(1,1,0)[24] with drift         : 101858.5
 ARIMA(3,0,0)(2,1,1)[24] with drift         : Inf
 ARIMA(3,0,0)(1,1,1)[24] with drift         : Inf
 ARIMA(4,0,0)(2,1,0)[24] with drift         : 101302.7
 ARIMA(4,0,0)(1,1,0)[24] with drift         : 101845
 ARIMA(4,0,0)(2,1,1)[24] with drift         : Inf
 ARIMA(4,0,0)(1,1,1)[24] with drift         : Inf
 ARIMA(5,0,0)(2,1,0)[24] with drift         : 101305.4
 ARIMA(4,0,1)(2,1,0)[24] with drift         : 101304.5
 ARIMA(3,0,1)(2,1,0)[24] with drift         : 101307.7
 ARIMA(5,0,1)(2,1,0)[24] with drift         : 101307.7
 ARIMA(4,0,0)(2,1,0)[24]                    : 101300.7
 ARIMA(4,0,0)(1,1,0)[24]                    : 101843
 ARIMA(4,0,0)(2,1,1)[24]                    : Inf
 ARIMA(4,0,0)(1,1,1)[24]                    : Inf
 ARIMA(3,0,0)(2,1,0)[24]                    : 101316
 ARIMA(5,0,0)(2,1,0)[24]                    : 101303.4
 ARIMA(4,0,1)(2,1,0)[24]                    : 101302.4
 ARIMA(3,0,1)(2,1,0)[24]                    : 101305.8
 ARIMA(5,0,1)(2,1,0)[24]                    : 101305.7

 Now re-fitting the best model(s) without approximations...

 ARIMA(4,0,0)(2,1,0)[24]                    : 101586.6

 Best model: ARIMA(4,0,0)(2,1,0)[24]   
 
# d=1, D=1, max.p=5, max.q=2, max.P=5, max.Q=2, max.order=10 m=168
 Fitting models using approximations to speed things up...

 ARIMA(2,1,2)(1,1,1)[168]                    : Inf
 ARIMA(0,1,0)(0,1,0)[168]                    : 122379.8
 ARIMA(1,1,0)(1,1,0)[168]                    : Inf
 ARIMA(0,1,1)(0,1,1)[168]                    : Inf
 ARIMA(0,1,0)(1,1,0)[168]                    : Inf
 ARIMA(0,1,0)(0,1,1)[168]                    : Inf
 ARIMA(0,1,0)(1,1,1)[168]                    : Inf
 ARIMA(1,1,0)(0,1,0)[168]                    : 121638
 ARIMA(1,1,0)(0,1,1)[168]                    : Inf
 ARIMA(1,1,0)(1,1,1)[168]                    : Inf
 ARIMA(2,1,0)(0,1,0)[168]                    : 121468.5
 ARIMA(2,1,0)(1,1,0)[168]                    : Inf
 ARIMA(2,1,0)(0,1,1)[168]                    : Inf
 ARIMA(2,1,0)(1,1,1)[168]                    : Inf
 ARIMA(3,1,0)(0,1,0)[168]                    : 121452.9
 ARIMA(3,1,0)(1,1,0)[168]                    : Inf
 ARIMA(3,1,0)(0,1,1)[168]                    : Inf
 ARIMA(3,1,0)(1,1,1)[168]                    : Inf
 ARIMA(4,1,0)(0,1,0)[168]                    : 121403.9
 ARIMA(4,1,0)(1,1,0)[168]                    : Inf
 ARIMA(4,1,0)(0,1,1)[168]                    : Inf
 ARIMA(4,1,0)(1,1,1)[168]                    : Inf
 ARIMA(5,1,0)(0,1,0)[168]                    : 121361.7
 ARIMA(5,1,0)(1,1,0)[168]                    : Inf
 ARIMA(5,1,0)(0,1,1)[168]                    : Inf
 ARIMA(5,1,0)(1,1,1)[168]                    : Inf
 ARIMA(5,1,1)(0,1,0)[168]                    : 118580.2
 ARIMA(5,1,1)(1,1,0)[168]                    : Inf
 ARIMA(5,1,1)(0,1,1)[168]                    : Inf
 ARIMA(5,1,1)(1,1,1)[168]                    : Inf
 ARIMA(4,1,1)(0,1,0)[168]                    : 118580.3
 ARIMA(5,1,2)(0,1,0)[168]                    : 118581.5
 ARIMA(4,1,2)(0,1,0)[168]                    : 118553.1
 ARIMA(4,1,2)(1,1,0)[168]                    : Inf
 ARIMA(4,1,2)(0,1,1)[168]                    : Inf
 ARIMA(4,1,2)(1,1,1)[168]                    : Inf
 ARIMA(3,1,2)(0,1,0)[168]                    : 118642.8
 ARIMA(3,1,1)(0,1,0)[168]                    : 119155

 Now re-fitting the best model(s) without approximations...

 ARIMA(4,1,2)(0,1,0)[168]                    : 122838.5

 Best model: ARIMA(4,1,2)(0,1,0)[168]               
 
```{r eval=FALSE, include=FALSE}

autoplot(acf(seis.h.train.ds, plot=F, lag.max = 168*2)) + scale_x_continuous()
autoplot(pacf(seis.h.train.ds, plot=F, lag.max = 168*2)) + scale_x_continuous()

qqPlot(fit$residuals)
gghistogram(fit$residuals)
Box.test(fit$residuals, type="Box-Pierce")
fit.forec <- forecast(fit, h=24*10)
plot(fit.forec, xlim=c(250, 300))


frequency(seis.h.train)
p<-168;d<-0;q<-0;P<-0;D<-1;Q<-0;
paste0("ARIMA(", p, ",", d, ",", q, ")(", P, ",", D, ",", Q, ")_", frequency(seis.h.train))
fit <- Arima(seis.h.train, order=c(p,d,q), seasonal=c(P,D,Q))
fit
#Diagnostics
tsdisplay(residuals(fit), lag.max=168*2)

p<-1;d<-0;q<-2;P<-1;D<-0;Q<-2;
fit <- Arima(seis.h.train, order=c(p,d,q), seasonal=c(P,D,Q))
#Diagnostics
tsdisplay(residuals(fit))
forecast()


```



```{r mstl on msts}
seis.h.train.m <- msts(seis.h.train, c(24, 168))
seis.mstl <- seis.h.train.m %>% mstl(s.window="periodic") #c(15, 7))
seis.mstl.fc <- forecast(seis.mstl, h=168*18)

autoplot(seis.mstl) + xlab("Week")
plot(seis.mstl[,2], main="trend")
lines(trend.s, col="red")
plot(rowSums(seis.mstl[,3:4]), main="seasonality",type="l")
lines(seasonality, col="red")
plot(seis.mstl[,5],  main="residuals")
lines(residuals, col="red")


plotting.model <- seis.mstl
plotting.forecast <- seis.mstl.fc
checkresiduals(plotting.model[,5])
Box.test(plotting.forecast$model$residuals, type="L")
residuals.acf <- autoplot(acf(plotting.model[,5], na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
residuals.pacf <- autoplot(pacf(plotting.model[,5], na.action = na.pass, plot=F, lag.max=168*5)) + scale_x_continuous() + labs(title = paste0("Series: residuals of ", plotting.forecast$method))
plot_grid(residuals.acf, residuals.pacf, nrow=2)

plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original") +
  xlim(52, 70) + ylim(0, 8750)
plot_forecast(plotting.forecast) + 
  autolayer(seis.h.test, series="Original")
plots <- show_overlap_and_diff(
  seis.h.train, plotting.forecast$fitted, xlab=seasonality.xlab,
  base.desc = "train series",
  compare.desc = paste0("refit with ", plotting.forecast$method),
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
plots <- show_overlap_and_diff(
  seis.h.test[1:length(plotting.forecast$mean)], plotting.forecast$mean, xlab=seasonality.xlab,
  base.desc = "test series",
  compare.desc = paste0("refit with ", plotting.forecast$method),
  overlap.ylab = "Mean hourly movement (nm)",
  diff.title = "Difference between ts",
  diff.ylab = "nm", diff.ylab.sec="% over ts span",
  diff.ylab.sec.accuracy = .01
)
plot_grid(plots[[1]], plots[[2]], nrow = 2)
accuracy(plotting.forecast, seis.h.test)
qqPlot(plotting.model[,5])

bptests <- data.frame(lag=integer(), `p-value`=numeric())
for (i in 1:10){
  bptests[nrow(bptests) + 1, ] <- c(i, Box.test(plotting.model[,5], lag = i, fitdf = 0, type = "Box-Pierce")$p.value)
}
bptests.plot <- 
  ggplot(bptests, aes(lag, `p.value`), pch="o") + 
    geom_point() + ylim(0,1) +
    labs(title="Box-Pierce tests for lags 1 to 10") +
    geom_hline(yintercept=0.05, linetype="dotted", color = "blue") +
    scale_x_continuous(breaks=1:10)
bptests.plot

```


```{r eval=FALSE, include=FALSE}
gc()
if (name == "MEM") {
  proj_file <- 'proj.mems.RData'
  save.image(paste0("/media/data/Documents/Uni/spatiotemp/villalobos/project/", proj_file))
  remove(proj_file)
}
```

